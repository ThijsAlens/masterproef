\documentclass[11pt,a4paper]{report}
% Indien je je thesis recto-verso wil afdrukken gebruik je onderstaande opties i.p.v. bovenstaande
%\documentclass[11pt,a4paper,twoside,openright]{report}
\usepackage[a4paper,left=3.5cm, right=2.5cm, top=3.5cm, bottom=3.5cm]{geometry}
\usepackage{graphicx}
\graphicspath{{./figs/}}                        % set graphics path to figs folder, ie now all file imports can be referenced relative to figs
%\usepackage[latin1]{inputenc}                   % om niet ascii karakters rechtstreeks te kunnen inputten
\usepackage[utf8]{inputenc}                    % commentarieer deze regel uit als je utf8 encoded files gebruikt in plaats van latin1
\usepackage[backend=biber, style=ieee, 
citestyle=numeric-comp, maxnames=99]{biblatex}  % make use of the biblatex package to cite references
\addbibresource{bib.bib}
\AtBeginBibliography{\footnotesize}

\usepackage{cmbright}                           % new improved font
\usepackage{listings}             		        % voor het weergeven van broncode
\usepackage[outputdir=cache]{minted}                     % for beautiful listings
\usemintedstyle{borland}
\usepackage{verbatim}					        % weergeven van code, commando's, ...
\usepackage{hyperref}					        % maak PDF van de thesis navigeerbaar
\usepackage{url}						        % URL's invoegen in tekst met behulp van \url{http://}
\usepackage[small,bf,hang]{caption}             % om de captions wat te verbeteren
\usepackage[final]{pdfpages}                    % gebruikt voor het invoegen van het artikel in pdf-formaat
%\usepackage{pslatex}					        % andere lettertype's dan de standaard types

%\usepackage{sectsty}					        % aanpassen van de fonts van sections en chapters
%\allsectionsfont{\sffamily}
%\chapterfont{\raggedleft\sffamily}

\usepackage{float}                              % De optie H voor de plaatsing van figuren op de plaats waar je ze invoegt. bvb. \begin{figure}[H]
%\usepackage{longtable}					        % tabellen die over meerdere pagina's gespreid worden
%\usepackage[times]{quotchap}                   % indien je fancy hoofdstuktitels wil
%\usepackage[none]{hyphenat}
%\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{siunitx}
\sisetup{detect-all}
\usepackage[acronym,xindy]{glossaries}
\makenoidxglossaries
\usepackage[version=4]{mhchem}                  % chemical formulas
\usepackage{tabularx}
\usepackage{booktabs}                           % nice tables
\usepackage{array}                              % fixed-width columns in tables

%%%% Tikz %%%%
\usepackage{pgfplots}
\DeclareUnicodeCharacter{2212}{−}
\usepgfplotslibrary{groupplots,dateplot}
\usetikzlibrary{patterns,shapes.arrows}
\pgfplotsset{compat=newest}
%%%%%%%%%%%% MAKE FIGURES MORE UNIFORM %%%%%%%%%%%%
\definecolor{darkgray176}{RGB}{176,176,176}
\definecolor{color0}{RGB}{255,127,14}
\definecolor{color1}{RGB}{44,160,44}
\pgfplotsset{
    every axis/.append  style={
        title style={draw=none},
        label style={font=\small},
        legend style={
            fill opacity=0.8,
            nodes={scale=0.8, transform shape}, {draw=none}
        },
        tick align=outside,
        tick pos=left,
        x grid style={darkgray176},
        xtick style={color=black},
        y grid style={darkgray176},
        ytick style={color=black},
        grid=both,
    },
    every axis plot/.append style={
        line width=1.0pt,
        mark size=1,
    },
}


% used commands
\usepackage{xspace}
\usepackage{idpz3syntax}
\usepackage{decision-table}
\newcommand{\fodot}{FO($\cdot$)\xspace}

%%%%%%%%%%%% choose your campus and language %%%%%%%%%%%%
\usepackage{fiiw} 



%door onderstaande regels in commentaar te zetten, of op false, kan je pagina's weglaten
%bijvoorbeeld het weglaten van een voorwoord, lijst met symbolen, ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%voorwoord toevoegen?
%\acknowledgementspagetrue
%\acknowledgements{voorwoord}			%.tex file met daarin het voorwoord
%abstract toevoegen?
%\abstractpagetrue
%\abstracts{abstract}					%.tex file met daarin het abstract
%lijst van figuren toevoegen?
%\listoffigurespagetrue
%lijst van tabellen toevoegen?
%\listoftablespagetrue
%lijst van symbolen toevoegen?
%\listofsymbolspagetrue
%\listofsymbols{symbolen}				%.tex file met daarin de lijst van symbolen


% Information about your discipline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\opleiding{Master in de \\industri\"ele wetenschappen}
\afdeling{elektronica-ICT}
%\afdeling{Software Engineer}
\campus{denayereng}                       % Define your campus and language (append "eng" to load the English template)
                                            % campuses: denayer, geel, gent, groept, brugge (denayereng, geeleng, ghenteng, groupteng, brugeseng)
\title{User-friendly Home\\ Automation using IDP}
\subtitle{}
\forenameA{Thijs}
\surnameA{Alens}
\forenameB{} %keep empty if no 2nd author
\surnameB{} %keep empty if no 2nd author
\academicyear{2024 - 2025}

% NOG PROBLEMEN MET VOORBLAD -> fiiw.sty lijn ~326
  

\promotorA[Promotor]{S. Vandevelde} %for English use Supervisor(s)
\promotorB[Supervisor]{L. Van Laer}

\input{abbreviations.tex}

\begin{document}
\preface%
Hoe moet ik de lay-out van de dingen die voor de inhoud komen, fixen in LaTex? Waarschijnlijk het makkelijkste om live te doen.
\section*{Preface}
een voorwoordje

\section*{Samenvatting}
Een home automation-systeem dient om een woning te automatiseren. Dit kan variëren van heel eenvoudige taken, zoals een licht inschakelen wanneer een schakelaar wordt omgezet, tot complexere taken zoals het regelen van de temperatuur — en daarbij ook de ramen, verwarming en gordijnen — afhankelijk van allerlei factoren. Het opzetten van dergelijke automatisaties is echter niet zo vanzelfsprekend. De gebruiker moet enige kennis hebben van home automation en een beetje kunnen programmeren. De meeste mensen beschikken niet over deze kennis en kunnen daardoor niet ten volle profiteren van de voordelen die home automation biedt.

Wij ontwikkelden een gebruiksvriendelijke applicatie die het voor iedereen mogelijk moet maken om hun huis te automatiseren, zonder dat daarvoor diepgaande technische kennis vereist is. We deden dit door bestaande home automation-systemen onder de loep te nemen en te onderzoeken waar verbeteringen mogelijk waren. Daarbij maakten we gebruik van \fodot, een taal gebaseerd op eerste-orde logica. Deze taal kan worden gebruikt met de redeneermachine IDP-Z3, die redeneert over de in \fodot beschreven kennis om verschillende taken uit te voeren. De \fodot-taal is echter, net als andere talen in de wereld van home automation, niet eenvoudig te begrijpen of te gebruiken. Daarom onderzochten we mogelijke alternatieven voor \fodot, waaruit bleek dat een blocks-based editor een goede optie zou zijn.

Vervolgens ontwikkelden we een applicatie die gebruikmaakt van zelfgemaakte blokjes om automatisaties te creëren. De blokjes worden vertaald naar een \fodot-beschrijving, die vervolgens door IDP-Z3 gebruikt kan worden om de automatisaties uit te voeren. We besteedden daarbij bijzondere aandacht aan de gebruiksvriendelijkheid van de applicatie, omdat we willen dat iedereen ermee aan de slag kan.

Om dit te testen, voerden we een gebruikerstest uit met 14 proefpersonen. Hoewel de resultaten van deze test met enige voorzichtigheid ge\"interpreteerd moeten worden, wijzen ze erop dat de applicatie gebruiksvriendelijk is. De testpersonen gaven aan dat ze zich, met behulp van de applicatie, redelijk zelfzeker voelen in hun vermogen om hun huis te automatiseren.

\section*{Summary}
A home automation system is designed to automate a house. This can range from very simple tasks, such as turning on a light when a switch is flipped, to more complex tasks like regulating the temperature — and with that, controlling windows, stoves and curtains — depending on various factors. However, setting up such automations is not always straightforward. The user needs to be somewhat familiar with home automation and have basic programming skills. Most people lack this knowledge and therefore cannot fully enjoy the benefits that home automation has to offer.

We developed a user-friendly application that aims to make it possible for anyone to automate their home, without requiring in-depth technical knowledge. We did this by analyzing existing home automation systems and identifying areas for improvement. In this process, we used \fodot, a language based on first-order logic. This language can be used with the reasoning engine IDP-Z3, which reasons over the knowledge described in \fodot to perform various tasks. However, the \fodot language — like many others in the home automation field — is not easy to understand or use. For this reason, we conducted a study of possible alternatives to \fodot, which showed that a blocks-based editor could be a good solution.

We then developed an application that uses custom-made blocks to create automations. These blocks are translated into a \fodot description, which can then be used by IDP-Z3 to execute the automations. We paid particular attention to the application's user-friendliness, as our goal was to make it accessible to everyone.

To test this, we conducted a user study with 14 participants. Although the results should be taken with a grain of salt, they indicate that the application is user-friendly. Participants reported feeling reasonably confident in their ability to automate their home using the application.

\begin{abstract}
    Is die abstract niet een beetje hetzelfde als de samenvatting?
\end{abstract}

\printnoidxglossary[type=\acronymtype]%
\clearpage

%\input{hfdst1}
%\input{hfdst2}
%\input{hfdst3}


% Eventueel enkele appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Bijlage met daarin het wetenschappelijk artikel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Beschrijving van deze masterproef in de vorm van een wetenschappelijk artikel}
%The thesis should also contain a short scientific article. If you write your thesis in Dutch, you must write the article in English, and vice versa. We advise you to employ the IEEE Manuscript Templates for Conference Proceedings (\url{https://www.overleaf.com/latex/templates/ieee-conference-template/grfzhhncsfqn}).

\chapter{Introduction}
\section{Positioning}
We are living in a world where automation is adopted increasing rapidly. From automatically sorting luggage to the right plane at the airport, to fully self-driving cars, automation is becoming an integral part of our lives. This evolution, paired with the emergence of the Internet of Things (IoT), where many devices have become ``smart'' and automation-ready, has not only revolutionized industries but also opened up new possibilities for homeowners.

In essence, home automation is a way to automate tasks in a home. These can be simple tasks such as automatically turning on lights upon entering a room, to more advanced operations like regulating home climate. This has the potential to significantly streamline daily routines, reduce costs, and improve overall comfort.

One way to configure a home environment is by using a home automation system that runs on a local server in conjunction with Home Assistant (HA). HA is an application that integrates various devices from different brands into a single functional app. It also provides a framework through which users can automate their homes.

A home automation system is essentially a set of rules that define the behavior of the home, making it well-suited for a knowledge-based system. Such a system requires the user to input a set of rules, which are then processed by a reasoning engine to make the necessary decisions.

IDP-Z3 is an example of such a reasoning engine, utilizing a formal description to define these rules. One of the key advantages of IDP-Z3 is its ability to separate knowledge from its application. This separation allows users to focus on defining the rules without needing to program the decision-making process themselves, as the reasoning engine handles this automatically.

\section{Problem statement}
One of the main challenges is the steep learning curve associated with setting up and maintaining home automation systems. If users wish to implement their own home automation, they can use home assistants user interface (UI). Automations, however, require that the user has a basic understanding of programming and is familiar with specific technical tools. This way they can manually modify the configuration files and troubleshoot any issues that may be presented, which is not easily done by non-experts.

IDP-Z3 can make this process simpler by making use of a declarative knowledge base, avoiding the need to program automations. However, the IDP-Z3 language itself is not particularly user-friendly for non-experts and can become quite complex, especially when dealing with intricate rules or scenarios. When users are confronted with a large problem domain, it can be difficult to maintain an overview and make necessary adjustments. It also has a lot of possibilities that are not useful in the context of home automation, which can be confusing or overwelming.

\section{Objectives}
This thesis seeks to address this issue by investigating how IDP-Z3, can be utilized to make home automation more accessible. Instead of needing to create automations, triggers, and aligning them with each other, the user only needs to describe the desired behavior of the home in a declarative language. A graphical user interface (GUI) that provides structure, along with a more limited subset of the IDP language, could help make IDP-Z3 a more viable option for home automation.\\
The primary research question addressed in this thesis is:\\
How do we design an IDP-Z3 framework that enables end-users to automate their homes in a user-friendly way?\\
This overarching question is further explored through the following sub-questions:
\begin{itemize}
    \item What is the optimal user-friendly interface for addressing this problem?
    \item Which subset of the IDP-language is needed to configure a home?
\end{itemize}
The objectives of this thesis are:
\begin{itemize}
    \item Decide on a subset of the IDP-language that has all the functionality needed for home automation.
    \item Design a user-friendly UI that is most suited for IDP in combination with home automation.
\end{itemize}





\chapter{Literature review}
In this chapter, we discuss existing research relevant to the topics covered in this thesis. First, we elaborate on home automation, with a brief overview of HA and how users can configure their homes using it. Next, we will explore the basics of \fodot and IDP-Z3. After that, we will examine existing user-friendly \fodot alternatives, highlighting their strengths and weaknesses in the context of this use case. To close we will discuss the state of the art and how we can learn from it.
\section{Home automation}
Home automation is a broad term used when discussing the automation of a home. It ranges from simple tasks, such as automatically turning on a light when entering a room, to complex tasks, like adjusting the house temperature based on various variables. It also refers to home security: when should the security camera automatically record, when should the doors automatically lock, what should happen if the alarm goes off, etc. Automating tasks, like automatically making coffee at the start of the day, is also considered part of home automation. Additionally, it can help manage energy consumption throughout the day to reduce costs.

Home automation consists of 3 main parts:
\begin{itemize}
    \item Smart home devices
    \item A smart hub/server
    \item An application
\end{itemize}

\paragraph{Smart home devices}
A smart home device (or smart device) can be either of two things: a sensor or an actuator. A sensor can detect an event, while an actuator can respond to a trigger. A simple example is a motion detector (sensor) that automatically turns on a light (actuator) when there is movement (trigger). Depending on the device, there may be some additional (smart) features. For example, the light could have an internal clock that provides the current time. This allows the light to automatically adjust its brightness based on the expected amount of natural light at that time. In summary, smart devices are the physical hardware (sensors and actuators) combined with software used for the communication between devices, which, in most cases, do not contain any smart home logic themselves.

\paragraph{Smart hub/server}
The smart hub is a central device that connects the complex hardware of smart devices to the user. Its function is to receive data from sensors and send commands to actuators, serving as a central hub for the devices, so to speak. This hub can be provided by a manufacturer specifically for their smart devices, or it can be a generic one designed to be compatible with as many devices as possible.

\paragraph{Application}
The application allows the user to configure their home. Most often, this is done through a graphical user interface (GUI) where the user can create automations, view the status of devices, monitor active automations, easily communicate with the devices, etc.

\subsection{Home assistant}
\label{HomeAssistant}

Home assistant (HA)~\cite{HA} is an open-source, all-in-one application for home automation. In a home environment, it typically  runs on a local server, where smart devices can be connected and configured. Because it is local, it provides strong security for user data. HA has a large and growing community, which ensures compatibility with a wide range of devices and brands, eliminating the need for multiple apps to control a home environment.\\
HA also offers multiple UIs (known as dashboards) where users can monitor the state of their home. Users can select a dashboard created by others, design one themselves, or build on an existing dashboard. They can interact with their devices directly through these dashboards. Additionally, users can create automations using a separate UI, which are actions executed when a set trigger occurs. Fully understanding how these automations work requires a deeper understanding of how HA functions.
In the following paragraphs we will discuss some terminology used inside HA. 
An overview of these concepts is shown in Figure~\ref{fig:ha_structure}.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/HA_structure.png}
    \caption{The main hierarchy of HA \protect\footnotemark}
    \label{fig:ha_structure}
\end{figure}


\paragraph{Entities}
These are the lowest level possible. They represent single sensors/actuators like a temperature sensor, a lightswitch, a light, etc.
\paragraph{Devices}
These are a group of entities. It could be that a device has 1 entity (ex. a lightswitch), but it also could have multiple entities (ex. a motion sensor that is also capable of capturing the temperature).
\paragraph{Areas}
These are groups of devices that could correspond to rooms in a house. For instance, the living room could have devices like a light-switch, a motion sensor (that detects if someone is in the room), a set of speakers, etc. All of these devices could be grouped together in one area.
\paragraph{Scenes}
Scenes are used to automatically set a set of devices to a predefined state. This could, for example, be to pre-configure the actuators of the living room to watch a movie. The user could set up a scene where, if activated, all the lights dim, the tv turns on and all the blinds in the living room close. 
\paragraph{Automations}
Automations are used to automate things. These automations consist of three things.
First a ``trigger'' needs to happen to activate the automation. This could, for example be, a motion sensor detecting movement. After the trigger, possible ``conditions'' are checked. These are additional requirements that need to be met before executing the automation, for example, ensuring someone is home. Finally ``actions'' are performed, these are the outcomes that occur after a trigger and when the conditions are met, like turning on the light in a room.
\paragraph{Scripts}
Scripts are predefined actions that are usable in automations. For example, a user may create a script to turn on all the lights in a room. This script can then be utilized in an automation that turns on the lights when someone enters the room. If the user later wants to create another automation to turn on the lights when the carport opens, they can reuse the same script. The benefit of scripts is their maintainability: if a new light is added to the room, the user only needs to update the script. Both automations will automatically use the updated script, eliminating the need to modify each automation individually.

\footnotetext{Icons by \url{https://www.flaticon.com/free-icons/pixel}} % footnote voor symbooltjes in fig:ha_structure

\subsection{Home assistant's UI}
As specified above, HA's UI has two parts. The dashboard, which is fully customizable by the user, and the automation editor, which is a pre-configured UI.
\paragraph{Dashboard}
The dashboard is the central interface where users control their smart home. It is primarily built using widgets, which can represent virtually anything the user envisions. For instance, a widget could represent a single room, containing sub-widgets to control each device within that room. Alternatively, a widget could display the entire house, allowing users to manage all devices from a single view. Users even have the option to create individual dashboards for each room if they wish. An example of a dashboard is found in Figure~\ref{fig:ha_dashboard_ex}. This dashboard is used as one of the demo's on the HA website~\cite{HA_demo}.

%While the possibilities are virtually endless, this flexibility can also pose a challenge: creating a custom dashboard from scratch might feel overwhelming for new users. To address this, HA provides support for community-built dashboards that users can adopt and expand upon as needed, making the experience more approachable and user-friendly.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/HA_dashboard_ex.png}
    \caption{An example of a dashboard in HA}
    \label{fig:ha_dashboard_ex}
\end{figure}

\paragraph{Automation editor}
The automation editor is designed for creating and editing automations. It follows a fixed structure: a trigger is specified first, followed by a condition, and concluded with an action.

This consistent structure offers a key advantage: users only need to learn one framework for creating automations. However, this approach has its drawbacks. Users still need to understand how devices should be utilized within this framework, which can be challenging without prior knowledge. Additionally, by managing automations across separate user interfaces, it becomes difficult to maintain a clear overview of what each automation is designed to do.

\subsection{Issues with the current automation configuration}
\label{home_automation_problems}

While Home Assistant provides its users with an all in one application with a UI for basic home configuration, it does not allow for more complex rules. The user will still need to dive in the configuration files themself to control their devices so they do what is needed. These configuration files are YAML-files, which are clear for people with an IT background, but can be difficult to follow for non-expert people. Fortunately, HA has an active community that often helps less experienced users navigate these difficulties.

Despite this support, the community still struggles to address certain challenges. As highlighted in~\cite{SOTA_AutomationConfigurationSmarthome}, users face three primary issues when modeling their homes in YAML: debugging (68\%), implementation (27\%), and optimization (5\%). The paper evaluates six validation tools, including the HA IDE, and reports that they have a very high precision (75\%-94\% of the identified errors were actual errors). However, they suffer from very low recall. The tools only identified 9-11 bugs out of 129.

This indicates that while validation tools exist, they are not very effective in practice. Robust validation is essential for users, as they are likely to encounter bugs or problems that cannot be resolved through an IDE. This often forces them to edit YAML files directly, which is not ideal. Even worse, if mistakes are made in the YAML files, identifying and correcting them becomes nearly impossible without better tools or an active community. When designing a user-friendly application, validation should be kept in consideration.



\section{\fodot}
\label{fodot}
\fodot \footnote{\fodot is pronounced ``Eff-Oh-dot''} (aka FO-dot) is the Knowledge Representation Language used by the IDP-Z3 reasoning engine~\cite{IDPZ3ReasoningEngine}. It is an extension of first-order logic (FOL), which makes use of the following logic operators $\land, \lor, \neg, \Rightarrow, \Leftrightarrow, \forall, \exists$, further described in Table~\ref{tab:fodot_symbols}.

\begin{table}
    \centering
    \caption{Explanation of symbols used by \fodot}
    \label{tab:fodot_symbols}
    \begin{tabular}{|c|c|c|}
    \hline
    \fodot symbol & ASCII characters & meaning \\ \hline
    $\land$  & $\&$ & logical and   \\ \hline
    $\lor$   & $\mid$ & logical or   \\ \hline
    $\neg$   & $\sim$ & logical not   \\ \hline
    $\Rightarrow$ & $=>$ & implication   \\ \hline
    $\Leftrightarrow$ & $<=>$ & equivalence   \\ \hline
    $\forall$ & $!$ & for all   \\ \hline
    $\exists$   & $?$ & for at least 1   \\ \hline
    \end{tabular}
\end{table}


The IDP-Z3 language consists of, at a minimum, a vocabulary and a theory. The vocabulary defines the problem domain and specifies the symbols that will be used in the theory. The theory consists of rules that apply to these symbols. The structure, which is optional, describes a single, specific situation. Here is a simple example to illustrate these blocks and the basics of \fodot, which will be explained further on.

\begin{idplisting}
vocabulary V {
    type Light
    type State := {On, Off, Dimmed}
    type ComplexState := {On, Off, Dimmed} <: State
    type SimpleState := {On, Off} <: State
    
    stateOfLight: Light -> State
    brightnessLvl: Light -> Int
    isSomeoneHome: () -> Bool
}

theory T:V {
    {
       // A light is Off if the brightnesslevel is equal to 0
       !l in Light: stateOfLight(l) = Off <- brightnessLvl(l) = 0.
       
       // A light is On if the brightnesslevel is greater then 0
       !l in Light: stateOfLight(l) = On <- brightnessLvl(l) > 0.
    }
    
    // if nobody is home, then all the lights should be off
    !l in Light: ~isSomeoneHome() => stateOfLight(l) = Off.
    
    // the brightnesslvl of all the lights should be divisable by 10 and stay between 0 and 100
    !l in Light: (brightnessLvl(l) >= 0) & (brightnessLvl(l) =< 100) & (brightnessLvl(l) % 10 = 0).  
    
    // the light l should be off, if and only if nobody is home or the brightnessLvl is equal to 0
    !l in Light: stateOfLight(l) = Off <=> (~isSomeoneHome() | (brightnessLvl(l) = 0)).
}

structure S:V {
    Light := {light1, light2, light3, light4}.
    stateOfLight :> {light1 -> On, light3 -> Off}.
    brightnessLvl :> {light2 -> 60}.
}


\end{idplisting}
This \fodot description outlines the functionality of lights within a smart home. The following sections break down and explain each block in detail.

\paragraph{Vocabulary}
The vocabulary is the first part of the \fodot description and specifies the domain of the problem. In this case it defines how a light is represented, as well as the state of the light. There is extra info about the possible states of the light, the value of ``State'' can only be ``On'', ``Off'' or ``Dimmed''. There are two more types defined, however these are subtypes of the type ``State''. This can be seen as a subset of states. There are two functions defined: ``stateOfLight'' and ``brightnessLvl''. Both map a ``Light'' to a ``State'' or an Integer, respectively. The third function, ``isSomeoneHome'', does not take any arguments and returns the build in type ``Boolean''.
\begin{itemize}
    \item ``stateOfLight'': it takes a ``Light'' and maps it to a ``State''. In effect, it represents the state (``On'' or ``Off'') of a given light.
    \item ``brightnessLvl'': it takes a ``Light'' and maps it to an Integer. In effect, it represents the brightness-level of a given light.
    \item ``isSomeoneHome'': it does not take any arguments and represents a Boolean (``True'' or ``False''). This is called a proposition. It could be seen as a constant that does not change in one structure.
\end{itemize}



\paragraph{Theory}
We will now go over the four formulas in the theory.
\begin{idplisting}
!l in Light: ~isSomeoneHome() => stateOfLight(l) = Off.
\end{idplisting}
The first rule ensures that \textit{if} nobody is home, \textit{then} the lights should be off.\\
In the \fodot world, this is called an implication. If the statement on the left of the implication symbol ($\Rightarrow$) is true, then the right statement also needs to be true. However, this does not mean that if the left statement is false, the right statement can not be true.
\begin{idplisting}
!l in Light: (brightnessLvl(l) >= 0) & (brightnessLvl(l) =< 100) & (brightnessLvl(l) % 10 = 0).
\end{idplisting}
This rule ensures that the brightness level of a light remains within the range of 0 to 100. Additionally, it enforces that the brightness increments are in multiples of ten.
\begin{idplisting}
!l in Light: stateOfLight(l) = Off <=> (~isSomeoneHome() | (brightnessLvl(l) = 0)).
\end{idplisting}
The third rule ensures that the light is off if either nobody is home or the brightness level is 0, and vice versa.\\
This kind of rule uses an ``if and only if'' construct, which is more commonly referred to as an equivalence. If the left formula is true, the right one is too and vice versa. Consequently, if one is false, the other must be too.

\begin{idplisting}
{
   !l in Light: stateOfLight(l) = Off <- brightnessLvl(l) =< 0.
   !l in Light: stateOfLight(l) = On <- brightnessLvl(l) > 0.
}
\end{idplisting}
A light is off, then the brightness level is 0 or smaller. A light is on when the brightness level is greater then 0.\\
This last rule is a definition. It is a convenient way to define a concept, in this case defining how a light should behave. All the relevant rules are grouped together, which makes it more elegant and more expressive. Important to note is the fact that definitions, unlike implications, need to be fully enumerated and need to capture the necessary and sufficient conditions. This means that all the possible cases need to be defined and when one of the conditions is met, it leads directly to the corresponding output.
In this case, the light can be ``on'' or ``off'', so the definition has defined both of these situations. When one of the two conditions is true, the other must be false. In other words, the brightness level of a light can either be smaller or equal to 0 or greater then 0.

\paragraph{Structure}
In the structure, a specific situation is defined. In this case, we declare that there are 4 lights and partially map some lights to states and brightness levels. The ``$:>$'' symbol stands for a partial interpretation. In this case, not all the lights are mapped. 



\section{IDP-Z3}
IDP-Z3~\cite{IDPZ3ReasoningEngine} is a reasoning engine capable of performing a variety of reasoning tasks on knowledge bases in the \fodot language. The idea is to provide knowledge (in the form of \fodot) that is used by the inference tasks of the IDP-Z3 system to produce an output. Because IDP-Z3 is build to implement the knowledge-base paradigm, it supports multiple inferences.

\subsection{The Knowledge-Base Paradigm}
The IDP-Z3 engine implements the Knowledge Base paradigm~\cite{IDPZ3KBParadigm}, in which systems store declarative domain knowledge in a knowledge base and use it to solve a variety of problems. Importantly, it states that the knowledge base should be separated from its inference tasks. This implies that the knowledge could be reused for multiple use cases within the same domain, unlike an imperative programming language where every inference would need its own separate program. Furthermore, if the KB changes, all of these programs would need to be rewritten. This is where the power of a knowledge-based system lies.\\
The multiple inference tasks are explained below using the example of the lights, shown in Section~\ref{fodot}.

\paragraph{Model expansion}
In the first place IDP-Z3 can generate models based on a given vocabulary, theory and structure. A model is a complete set of values that satisfies the theory. Figure~\ref{fig:IDP-Z3_model-generation} shows 3 possible models of the lights example. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/IDP-Z3_model-generation.png}
    \caption{10 possible models in line with the provided theory and structure}
    \label{fig:IDP-Z3_model-generation}
\end{figure}

\paragraph{Propagation}
The reasoning engine can compute all the logical consequences of a theory. In the first implication of the theory, it is stated that if no one is home, the light needs to be in the ``Off'' state. So, if the lights are on, IDP-Z3 can infer that there must be someone home.

\paragraph{Explanation}
IDP-Z3 can provide an explanation to certain models and tell the user why one can or cannot exist. This is a task that, among other uses, is used in the Interactive Consultant UI in the online IDE, which is shown below in Figure~\ref{fig:IDP-Z3_interactive-consultant_light-example} and is further explained in Section~\ref{interactive_consultant}.

\paragraph{Optimisation}
The reasoning engine can optimize models. For example, the second rule of the theory states that the brightness-level of a light needs to be between 0 and 100 and that it is divisible by 10. It can work out that the smallest possible number of the brightness is 0. An example of this is shown in Figure~\ref{fig:IDP-Z3_interactive-consultant_optimization-example}

\paragraph{Relevance}
IDP-Z3 can figure out if there are any irrelevant symbols in the KB. Some rules of the theory are repeated below to further explain this. Rule 1 states that a light is ``Off'' either when the brightness-level of that lamp is 0 or nobody is home (and vice versa because it is an equivalence). However, not all the symbols this rule produces are meaningfull for the KB:\\
The definition (1) states that a light is of when the brightness level of said light is 0 or smaler. So when the light is turned off, the constant ``isSomeoneHome()'' is not relevant anymore since it only defines when the light should be off. 

\begin{idplisting}
{
   !l in Light: stateOfLight(l) = Off <- brightnessLvl(l) =< 0.
   !l in Light: stateOfLight(l) = On <- brightnessLvl(l) > 0.
}
!l in Light: ~isSomeoneHome() => stateOfLight(l) = Off.
!l in Light: stateOfLight(l) = Off <=> (~isSomeoneHome() | (brightnessLvl(l) = 0)).
\end{idplisting}

%\begin{itemize}
    %\item It can produce models based on the knowledge that is provided (model expansion)
    %\begin{itemize}
    %    afbeelding van de output (IDP-Z3\_model-generation.png)
    %\end{itemize}
    %\item It can understand links between types (propagation)
    % \begin{itemize}
    %     \item[] The light can be on or off if someone is home. This is defined in the first implication (first line in the theory).
    % \end{itemize}
    % \item It can explain why a sertain model can exist (explanation)
    % \begin{itemize}
    %     \item[] afbeelding van den interactive consultant (IDP\_Z3\_model-explanation.png)
    % \end{itemize}
    % \item It can optimise situations (optimisation)
    % \begin{itemize}
    %     \item[] The second rule of the theory states that the brightness-level of a lamp needs to be between 0 and 100 and that it is divisible by 10. It can work out that the smallest possible number of the brightness is 0.
    % \end{itemize}
    % \item It can check if some knowledge is redundend (relevance)
    % \begin{itemize}
    %     \item[] The last rule states that if a light is off, either the brightness-level of that lamp needs to be 0 or nobody can be home. Because of the $\Leftrightarrow$, this rule works both ways. So, if the brightness-level of a lamp is 0 or nobody is home, that light should be off. However when nobody is home, the light should already be off (the first rule of the theory). IDP-Z3 can work this out by itself.
    % \end{itemize}
%\end{itemize}

%% The output of the reasoning engine provides possible models, all of which comply with the provided theory. It also shows that the reasoning engine has assigned values to the ages of the individuals, even though these were never specified in the \fodot description. This demonstrates the power of separating the knowledge (\fodot description) from the interpretation (performed by IDP-Z3). A single knowledge base (KB) can be used for multiple purposes: it can generate models (as in this example), validate a model, or teach a user the thought process behind a certain decision.
% "The KB is ``only'' a formal representation of declarative properties of the domain. This imposes a strong requirement on the KB language (\fodot): its expressions should be interpretable as (informal) propositions about the domain, and this interpretation, its informal semantics, should be as clear, precise, and objective as possible" (Building a Knowledge Base System for an Integration of Logic Programming and Classical Logic).
% This approach contrasts strongly with declarative programming frameworks, where each operation (generation, validation, explanation, etc.) must be separately programmed. Moreover, if a change occurs, all programs must be rewritten, whereas in a system with a separated KB and interpretation, only the KB needs to be updated.

\subsection{Interactive consultant}
\label{interactive_consultant}
As said before, the Interactive Consultant~\cite{InteractiveConsultant} (IC) is a UI integrated into the online IDE of IDP-Z3, allowing users to interact with and test their constructed KB. Each time the user enters a value, the IC automatically adjusts the other values so that they are in line with the KB. This can be a great tool to get insight in a KB. The usefulness is further explained using the example of the lights from Section~\ref{fodot}.

As shown in Figure~\ref{fig:IDP-Z3_interactive-consultant_light-example}, the IC explains to the user why certain behavior is implied. In this case, the KB states that a light is ``On'' if the brightness level of that light is greater than 0. So when the user sets the brightness level of ``light1'' to 40, the light should be ``On''. The ``isSomeoneHome()'' predicate also became ``True''. This is because if no one is home, all the lights should be ``Off''. This is a great showcase of how IDP-Z3 can propagate value assignment.

It can also explain to the user why a combination of values, created by the user, cannot exist, as shown in Figure~\ref{fig:IDP-Z3_interactive-consultant_error-example}. The user wanted to make the brightness level of ``light2'' 45, which is in conflict with the rule that states that the brightness level of every light must be between 0 and 100 and be divisible by 10.

The IC can also optimize the value of numerical symbols. As shown in Figure~\ref{fig:IDP-Z3_interactive-consultant_optimization-example}, ``light1'' is minimized by pressing the button hovered over by ``light2''. The brightness level is 0, because if the light is ``Off'', its brightness level can be 0. It can not be any lower because of the rule that states that the brightness level of any light must be between 0 and 100 and be divisible by 10. ``light3'' however is turned on, so its brightness level cannot be 0. It also cannot be 1 because of the same rule that limits the brightness level.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/IDP-Z3_interactive-consultant_light-example.png}
    \caption{An example off how the Interactive Consultant explains a model}
    \label{fig:IDP-Z3_interactive-consultant_light-example}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{images/IDP-Z3_interactive-consultant_error-example.png}
    \caption{An example of how the Interactive Consultant explains why a model can not exist}
    \label{fig:IDP-Z3_interactive-consultant_error-example}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/IDP-Z3_interactive-consultant_optimization-example.png}
    \caption{An example off how the Interactive Consultant optimizes over something}
    \label{fig:IDP-Z3_interactive-consultant_optimization-example}
\end{figure}



\section{Alternatives for \fodot}
Given that \fodot can be difficult to learn and understand for non-expert users, it is useful to explore other options for more accessible notations. In this section, we consider alternative options in the context of home automation.

\subsection{DMN}
The Decision Model and Notation (DMN) standard~\cite{DMN} is a user-friendly notation for decision logic. It is managed by the Object Management Group (OMG), and aims to be an intuitive language that can be used by anyone involved in the modeling process. A DMN model has two main components:
\begin{itemize}
	\item Decision Requirements Diagram (DRD)
    \item Decision Tables (DT)
\end{itemize}

\paragraph{Decision Tables}
A DT describes a decision. It defines the output based on a set of input variables. It requires these variables to be fully enumerated, meaning that all possible combinations must be covered. It also needs to capture the necessary and sufficient conditions. These conditions ensure that all criteria must be met to produce a particular output, and when one condition is met, it leads directly to the corresponding output.\\
The example shown in Figure~\ref{fig:DT} represents the definition of the lights example, of which the \fodot representation can be found below. It states that \textit{if} the brightness level of a light is greater then 0, \textit{then} that light is ``On''; \textit{if} the brightness level of a light is 0, \textit{then} that light is ``Off''. Important to note is that all DTs can be represented by a \fodot definition, but not all \fodot definitions can be represented by a DT. Similarly, implications cannot be represented in a DT. This is a problem, because an implication is a very important part of \fodot and it is needed for modeling a home.

\begin{idplisting}
{
   stateOfLight() = Off <- brightnessLvl() =< 0.
   stateOfLight() = On <- brightnessLvl() > 0.
}
\end{idplisting}

\begin{figure}
    \centering
    \dmntable{Define state of light}{U}{brightnessLevel}{stateOfLight}{
    $\geq 0$, on,
    $\leq 0$, off
}
    \caption{An example of a Decision Table using the example of the lights}
    \label{fig:DT}
\end{figure}

\paragraph{ Pros and cons}
The main advantage of using DMN is its clarity and user-friendliness. The user does not need any programming knowledge to model with it effectively. However, a significant drawback is its limited capabilities. When the user attempts to describe more complex situations, it can quickly become very unreadable, so much so that some solutions to those situations fail to meet DMN's readability goals.
 
\paragraph{cDMN}
cDMN~\cite{cDMN} is an extension of DMN that addresses the shortcomings of standard DMN by introducing constraint modeling, quantification, types, and functions. By adding these things, an implication is possible, as shown in Figure~\ref{fig:cDMNTable}. Not all possible states of ``isSomeoneHome'' are described in the table. If no one is home, the light should be off, it does not specify what should happen if someone is home. The \fodot code that represents this table is shown below.
 
\begin{idplisting}
~isSomeoneHome() => stateOfLight() = Off.
\end{idplisting}

\begin{figure}
    \centering
    \dmntable{Disable lights if nobody's home}{E*}{isSomeoneHome}{stateOfLight}{
        No, off
    }
    \caption{An example of a cDMN table using an implication of the example of the lights}
    \label{fig:cDMNTable}
\end{figure}
 
\subsection{CNL}
\label{CNL}
A Controlled Natural Language~\cite{CNL} (CNL) is a subset of a natural language (e.g. English) that is strictly defined. This allows it to be understood by both a computer and a human. This is useful because the domain experts do not need an expert on the language. According to~\cite{CNLAttemptoControlledEnglish}, a CNL consists of two parts:
 \begin{itemize}
 	\item A subset of a language used as ``syntax'' 
     \item A parsing engine so the computer can understand the language
 \end{itemize}
 IDP-Z3 has its own CNL, which we will use as an example.

\paragraph{The IDP-Z3 CNL}
The example of the lights, shown below in CNL form, is used to further explain the concept of CNL. This natural language representation is likely to make it much more readable to the average person. Another way in which the online IDE makes use of this CNL is in its Interactive Consultant. In the screenshot shown in Figure~\ref{fig:IDP-Z3_interactive-consultant_light-example} the explanation is useful and helps the user understand what is going on, but it still requires some understanding of FO symbols, which is not ideal.
The example below shows the CNL as a replacement for \fodot. While it is more readable, there is still a clear reference to the \fodot language. It feels unintuitive to say ``for all l in Light'', instead of ``for every Light l''. While the second phrasing is clearer for humans, the order change makes it so the IDP-Z3 system can not understand it.

\begin{idplisting}
{
for all l in Light: stateOfLight(l) = Off if brightnessLvl(l) =< 0.
for all l in Light: stateOfLight(l) = On if brightnessLvl(l) > 0.
}
\end{idplisting}

\paragraph{Pros and cons}
A CNL allows the user to create easy-to-read code because it uses a subset of a known language, removing the need of a technical expert on the used language. However, it is not the easiest to write due to its strictness with the ordering of words, which can introduce confusion. Two structures that seem the same to us humans, may be interpreted differently by the computer. The limited set of words available in a CNL can also pose challenges. While the user might prefer to write in natural, unrestricted text as they are accustomed to, the computer is unable to interpret such input. This challenge, known as the writability problem~\cite{CNL}, highlights the difficulty of creating a language that remains readable without introducing ambiguity, so the computer can still understand it.
These restrictions can lead to an unintended consequence: writing in a CNL may become more challenging than learning the actual language it is meant to simplify. Users can become frustrated because they need to learn the boundries of the CNL as well as the syntax.

\subsection{Blocks-based editor}
A blocks-based editor is a user-friendly way to write software using blocks. This allows the user to avoid memorizing syntax, as the blocks are provided and visually indicate what is possible and what is not, eliminating the need to understand complex syntax rules. In other words, syntax errors are non-existent, allowing the user to fully focus on what the application should do, rather than how to write it in a certain language.

A well-known example of a blocks-based programming enviroment is Scratch~\cite{scratch}, a blocks-based interface in JavaScript. It allows users to create programs in a visual workspace, while processing the blocks into runnable JavaScript code. Scratch is a code editor designed for children, ensuring that it needs to be understandable even for the youngest users.

\paragraph{\fodot blocks-based editor}
There already exists a blocks-based editor for \fodot~\cite{IDPStructuredBlockbasedEditor}. It uses Blockly~\cite{Blockly}, an extendable blocks-based editor developed by Google. It has two components:
\begin{itemize}
	\item A workspace where blocks can be placed
	\item A generator where blocks are translated to a textual representation (in this case \fodot)
\end{itemize}
An example of this editor is shown in Figure~\ref{fig:blockly_IDP_example}. In this editor the three main blocks of the \fodot language are still clearly visible as well as the form of the \fodot syntax. The vocabulary has types, functions and predicates to define the problem domain. The theory has a formula and a definition, where the underlying \fodot syntax is still very apparent. The first block of the vocabulary can be easily translated into \fodot-syntax, as shown below. As this is a blocks based editor for the entire \fodot syntax, it is likely too complex for what is needed for IoT in home automation. Still, it could provide a good baseline to start from.
\begin{idplisting}
type Vertex := {1..3}
\end{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/blockly_IDP_example.png}
    \caption{An example of a Blockly editor for \fodot~\cite{IDPStructuredBlockbasedEditor}}
    \label{fig:blockly_IDP_example}
\end{figure}

\paragraph{Pros and cons}
A blocks-based editor is very clear and easy in how to use it. The user can not make syntax errors, because they can see what blocks fit each other and which do not. This implies that no expert of the language (or blocks) is needed to create a working project. However, by making it all visual, it can get messy quite quickly. For bigger projects, that need more complex functionality, the workspace can get very unorganised and difficult to navigate. There are some ways to try and fix this, for example by creating a new block with combined funtionality which is described in its own workspace. 

An overview of the meaningful pro's and con's of all the discussed user-friendly interfaces can be found in Table~\ref{tab:user-friendly_comparison}.

\begin{table}
    \centering
    \caption{Comparison of possible user-friendly interfaces \fodot}
    \label{tab:user-friendly_comparison}
    \begin{tabular}{|c|c|c|c|}
    \hline
    User-friendly interface & Graphical interface & Low code & Sufficiently expressive \\ \hline
    DMN & x & x &   \\ \hline
    IDP-Z3 CNL &  &  & x  \\ \hline
    Blocks-based editor & x & x & x \\ \hline
    \end{tabular}
\end{table}

\section{State of the art}
When considering how AI can help both with user-friendliness and how the user describes their home automation system, according to \cite{SOTA_KnowledgeBasedAIInHomeAutomation}, knowledge-based AI fits into this perfectly. It is easier for non-experts to create a knowledge-based home automation system than it is to create a traditional imperatively programmed system because a KB system is much more flexible. However, it still requires the user to modify the rules of the KB when circumstances change.

\subsection{IntelliDomo}
IntelliDomo~\cite{SOTA_OntologyBased} is an ontology-based interface for home automation. It uses an ontology (OntoDomo) to represent the KB, production rules written in Semantic Web Rule Language (SWRL) to describe the system, and an inference engine (Jess) to make decisions.

The KB is represented in OWL files (Ontology Web Language), which are created by the system using existing ontologies. This is convenient when an appropriate ontology already exists; however, if there is none, the user must understand OWL to create their own. IntelliDomo uses SWRL in combination with a custom-made UI for rule construction. This ensures that users cannot make syntax errors, as all possible options are predefined. However, the UI still has the SWRL syntax in it, so it still requires the user to know SWRL even tough they do not need to write any. It can be challenging for non expert users to follow the SWRL logic. As shown in Figure~\ref{fig:IntelliDomo_UI}, the rules are constructed in the lower part of the UI using the predefined upper part. The constructed rules are difficult to read and understand once created. If there were to be a mistake made by the user, they would be required to change the rules in the SWRL syntax or completely reconstruct the rule from scratch. It also fails to give the user any feedback on the functionallity of thhere created rules, which is needed as explained in Section~\ref{home_automation_problems}. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/IntelliDomo_UI.png}
    \caption{The IntelliDomo UI~\cite{SOTA_OntologyBased}}
    \label{fig:IntelliDomo_UI}
\end{figure}

\subsection{User-configurable semantic home automation}
\label{USHAS}
User-configurable semantic home automation~\cite{SOTA_AutomationConfigurationSmarthome} (USHAS) is another system that uses a knowledge-based approach to home automation. They use the Web Ontology Language~\cite{OWL}, OWL for short, as a language for their ontology. They have six main concepts, also called first-level classes:

\begin{itemize} 
    \item Person, to represent people present in the home. The class is split into subclasses like child, adult... Each person has two properties: a name and their location. 
    \item Location, to represent the different rooms in the house. These are connected semantically, which means that the system can understand the relationships between them. For example, a kitchen is part of the first floor, which is part of the house. This enables the user to create rules that can apply to all devices located in a certain room. 
    \item Device, to represent the devices in the house. The class is split into two subclasses: ``ApplianceCategory'' (devices with the same states, for example a light and a lightswitch) and ``FunctionalCategory'' (devices with the same function, for example a remote volume controller and the manual knob on the box). Each device has a location, states, and events. 
    \item Time, to represent the time of day. This is important for home automation, as it can be used to trigger certain actions at specific times. It is also capable of representing repeating events, like ``every Monday at 14:00''. 
    \item Environment, to represent the environment in and around the house. This includes things like temperature, humidity, light, and noise levels, which can be used to trigger certain actions. Also, user-defined variables can be expressed by creating an extra environment property. 
    \item Event, to represent the events that can occur in the house. This includes things like a person entering or leaving a room, a device being turned on or off, or a change in the environment. These events can be used to trigger certain actions. 
\end{itemize}

The USHAS system uses a CNL-like UI to allow users to create their own ontology and rules, which are written in their custom Semantic Home Process Language (SHPL) in XML files. These consist of four main components: preconditions, variables, execution time, and flow of invocations. For example, given a command ``if the temperature is higher than 30 °C at 6:00 PM, turn on the air conditioner'', the value 30 is a variable; ``if the temperature is higher than 30 °C'' is a precondition, 6:00 PM is an execution time, and ``turn on the air conditioner'' is an invocation. All of these can be found in their UI. However, this way of creating rules, can be confusing for users who are not home in this field. As Figure~\ref{fig:USHAS_UI} shows, one rule requires many different components that might not be intuitive for the user to fill in.


\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/USHAS_UI.png}
    \caption{The USHAS UI~\cite{SOTA_AutomationConfigurationSmarthome}}
    \label{fig:USHAS_UI}
\end{figure}

These papers demonstrate that there is a value in a knowledge-based approach to home automation, but it is important to note that their approach to model homes and create rules is not the most user-friendly one. This is however very important when it comes to home automation for laypeople.

\subsection{Smart Block}
\label{SmartBlock}
SmartBlock~\cite{SOTA_SmartBlock} is a user-friendly blocks-based interface for the SmartThings IoT platform. They built their editor using Blockly~\cite{Blockly}, a JavaScript framework for creating blocks-based editors. An example of what the editor looks like is shown in Figure~\ref{fig:smart_block_UI}. It describes that if ``lock1'' has gone from ``locked'' to ``unlocked'' and ``presenceSensor1'' has detected something, then ``light1'' should turn on and ``musicPlayer1'' should start playing. The blocks are colour-coded to make it easier for users to understand what blocks should go together. It is also worth mentioning that they added tools to check for inconsistencies and mistakes made by the user.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/smartBlockRule.png}
    \caption{The SmartBlock UI~\cite{SOTA_SmartBlock}}
    \label{fig:smart_block_UI}
\end{figure}

They conducted a user study with 33 participants from diverse backgrounds (including IT). First, the participants were asked to model a rule to get familiar with the editor. 81\% of them responded positively or neutrally to the ease of use. After this introduction, the participants were tasked with modeling three progressively more challenging rules. Over time, they got better at this, which was shown by how much faster they were able to complete the tasks. Interestingly, the difference in performance between non-IT and IT participants was not that big, which further shows how user-friendly the editor is.

Another test required the participants to identify some errors in a given SmartApp. This proved to be more difficult without assistance, as the debugging tools lacked any semantic error correction. This highlights why having a tool to correct mistakes during the modeling process is so important.

This paper proves that a blocks-based editor is a viable option for home automation. It shows that such an editor is user-friendly and accessible to people without an IT background. It also confirms the importance of tools that can help with semantic errors.

\subsection{Event based home automation}
Another approach to home automation is an event-based system~\cite{SOTA_EventCalculus}. Instead of thinking in terms of states and their changes, it focuses on events and the logical consequences of those events. For example, if the front door opens, the lights in the hallway should turn on. After that, it is plausible that the person who just walked in will either walk to the living room, kitchen, or upstairs, so the system can predict this and narrow down the possible next actions that need to be taken. So instead of modeling different rules, this approach focuses on a stream of events that lead to a specific goal and making that as user-friendly as possible.

The formalism used to achieve this is called Event Calculus. It is a formalism for representing and reasoning about events and their effects over time. It is a first-order logic system and therefore allows for the representation of complex temporal relationships between events. It is also possible to reason over the written rules. An example of how this could be done is explained with the process of preparing a cup of tea. Normally, one would boil water, grab a cup and a teabag, after which the water is poured into the cup and the teabag is added. The initial action (turning on the kettle) is the event that starts the process, so from that point, the system can predict what the next steps should be. If one of the steps is not done, it can be inferred and explained to the user. In that way, the system can help users who are unfamiliar with the process or users who tend to forget the necessary steps. Another useful side effect of using a first-order-based system is the fact that it can be updated as new data comes in. This means that the system can learn from the actions of the user and adapt to their preferences. For example, if a user always turns on the kettle when they get home, the system can learn this and automatically turn on the kettle when it detects that the user gets home. The initial action is now the user arriving home.

However, all this knowledge needs to be provided by the user, which is not done in the most user-friendly way. They use a first-order logic language to describe these event flows, which, for a non-expert, is not easy to write nor understand. The tea example, in the formalized language, is shown in Figure~\ref{fig:event_code}. However, with the learning capabilities of the system, this is somewhat masked, as the system can learn from the user and adapt to their preferences.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/event_code.png}
    \caption{An example of the Event Calculus code for making a cup of tea~\cite{SOTA_EventCalculus}}
    \label{fig:event_code}
\end{figure}

\chapter{An \fodot description for home automation}
\label{home_automation_and_fodot}
In this chapter, we will discuss different ways to model a home automation system in \fodot. However, before we can do that, we need to figure out what the user expects from their home automation system, and how we can achieve a meaningful and logical description that offers a lot of flexibility while keeping it straightforward enough to be recreated using ``simple'' blocks. We will discuss the advantages and disadvantages of these implementations, and which of these we will use going forward.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/fodot-structure_example.png}
    \caption{An example of a home automation system used to explain the different \fodot implementations}
    \label{fig:fodot-structure_example}
\end{figure}

\section{Home automation description}
To decide on the modeling approach for the home automation system, we use a goal-oriented approach. This means that we will look at what the system needs to do and how the user will want to interact with it, and design our system accordingly. We will discuss some example situations that people would want to model. By creating situations, we also have a good idea of what the limitations of our \fodot description can be.

\paragraph{Devices}
Devices are the cornerstone of any smart home, so we will need to model these as intuitive as possible, making it so there is no need to understand how the devices are configured in the application. Each device has a number of possible states it can be in. For example, a lightswitch can be ``On'' or ``Off'', or a blind can possibly be ``opened'' or ``closed''. The user could configure these states themselves, but most devices already have a standard set of states. 

\paragraph{Areas}
The user will want to configure their devices in a way that matches the layout of their home so that they can create rules that apply to devices in a room, which can be very handy. The user can, for example, create a rule that turns off all the lights in the bedroom when nobody is in said bedroom. Since they will set up the areas to match their house, it will create a new way for them to understand what they are doing and therefore make the system more intuitive to use. It is similar to USHAS'~\cite{SOTA_AutomationConfigurationSmarthome} approach, where all the areas are semantically connected, as explained in Section~\ref{USHAS}. This also enables the user to create rules for ``super-areas'', which must also hold for all the areas that fall under it. For example, all the areas are part of the house, the user can create a rule that turns off all the lights when they leave the house.

\paragraph{Behaviour}
\label{Behaviour}
It is important to think about what the user would want to configure and what rules they would want to create. Below are some examples of such rules, in increasing complexity.
\begin{enumerate}
    \item[R1.] Turn on a light when a lightswitch is turned on.
    \item[R2.] Set the power of a fan to 50 when the temperature sensor gives a value of 25.
    \item[R3.] Set an RGB light to yellow when the lightswitch is turned on.
    \item[R4.] Open a blind and trigger an alarm when it is 8 o'clock.
    \item[R5.] Turn on all the lights in the house when motion sensor 1 or 2 is triggered at 2 o'clock.
    \item[R6.] Close all the blinds in the house and set the thermostat to 16 degrees when it is 10 o'clock.
    \item[R7.] Turn off all the lights in the living room and turn on all the lights in the kitchen when motion sensor 1 is triggered.
\end{enumerate}

\section{\fodot knowledge base} 
\label{fodot_knowledge_base} 
The vocabulary is an important part of the \fodot specification as it defines the possibilities and limits for the rest of the specification. There are lots of different aproaches possible, which we will explore with a focus on ease of use and effectiveness in a real-world application. We will use the rules, described in Section~\ref{Behaviour}, as examples of what the user would want to be able to model. The theory, and therefore the possible rules, is directly affected by the choice of vocabulary, so this also needs to be considered. It is also important that the generated \fodot specification does not differ too much from the editor the user will end up using, since we want to make use of the IC as a way to verify the constructed knowledge base. If the specification is too different from the blocks, the user will not recognize what blocks are responsible for the errors in the IC.

\paragraph{Approach 1}
As a first approach, consider a vocabulary where all the devices are defined as constants, and every device is linked to an area as shown below.

\begin{idplisting}
vocabulary V {
    type Area := {living_room, kitchen, floor_1, floor_2, house}

    light1: -> Area
    type stateOfLight := {0..100}
    stateOfLight1: -> stateOfLight

    lightSwitch: -> Area
    type stateOfLight_switch := {on, off}
    stateOfLight_switch: -> stateOfLight_switch
    .
    .
    .
}

theory T:V {
    stateOfLight_switch() = off => stateOfLight1() = 0.
}
\end{idplisting}

The problem with this way of representing the devices is that there is no way to group them, consider, for instance R7. It is an example of a rule that requires grouping devices by their location, which is not possible. The user also cannot implement any form of grouping in the devices; take R5 as an example, it is not possible to enumerate over all the light devices using this vocabulary. The states of these devices are represented through a type that defines all possible states for that device. In combination with this, there is a function that represents what state the device is in.

Another shortcoming of this vocabulary is the inability to represent relations between areas. This is because the vocabulary does not allow grouping of devices or areas. This is also something the user would want otherwise R6 would be very tedious to model.

\paragraph{Approach 2}
As a second approach, we can add an explicit type ``Device'' under which all specific instances of devices fall. This allows for the creation of rules that apply to all devices, specific devices, and areas. All the rules from Section~\ref{Behaviour} should be possible with this vocabulary. However, it also does not look that pretty in \fodot, since every new device, even if it is of the same type (light1, light2), needs to be defined with its own type. This means that the user needs to specify, for each device, what states it has. This is not ideal, since the user will need to specify the states of the devices every time they create a new device.

\begin{idplisting}
vocabulary V {
   type Device := {bell, light1, light2, motionSensor, lightSwitch}
   type Area := {living_room, kitchen, floor_1, floor_2, house}

   deviceIsInArea: Device -> Area

   deviceIsBell: Device -> Bool
   type BellState := {ringing, off}
   bellState : Device -> BellState
}
\end{idplisting}

\paragraph{Approach 3}
The third approach has a completely different view to the problem. Instead of focusing on the devices themselves, the focus now lies on the states of the devices and their grouping. By using subtypes, different instances of devices can be created according to their state. For example, a motion sensor is binary (motion detected or no motion detected), but a light switch is also binary (on or off), so these can be grouped together. This vocabulary can behave just like the previous one, in the sense that if all devices have different states, it will result in the same behaviour, but it opens up possibilities for more complex rules. By using subtypes, we still only use one function to state what state a device is in, as well as what area it is in. This makes the implementation behind the scenes much easier.

\begin{idplisting}
vocabulary V {
    type Device := {light1, light2, motionSensor,
    lightSwitch, curtain}
    type State := {on, off, opened, closed}
    type Area := {house, floor1, floor2, kitchen, living_room}

    deviceIsInArea: Device -> Area
    // subArea * superArea -> Bool
    areaIsSubAreaOf: Area * Area -> Bool
    deviceIsInState: Device -> State

    type BinaryDevice := {light1, light2,
                          motionSensor, lightSwitch} <: Device
    type BinaryState := {on, off} <: State
}
\end{idplisting}

It is also important to note that not all devices use strings as states. For example, a dimmable light, which needs to be set to a specific brightnesslevel, or in practice a number between 0 and 100. This is a problem with the third vocabulary, because we have one function that describes the state of a device, ``deviceIsInState'', which maps a ``Device'' to a ``State''. Because of the fact that ``State'' only has elements of the type ``string'' (which can not combine with integers), we can not integrate devices that require integers as states. However, it is solvable by creating a second function that maps a ``Device'' to an ``Int'', below called ``numberDeviceIsInState''. By doing this, we have created a seperation in the devices based on how their state requires them to be defined. In our blocks-based interface we should be able to hide this from the user.

\begin{idplisting}
Vocabulary V {
    type StringDevice := {light_1, light_2}
    type NumberDevice := {dimmable_light}
    type StringState := {light_on, light_off}
    type Area := {home, kitchen, living_room}   

    stringDeviceIsInArea: StringDevice -> Area
    numberDeviceIsInArea: NumberDevice -> Area
    // subArea * superArea -> Bool
    areaIsSubAreaOf: Area * Area -> Bool    

    stringDeviceIsInState: StringDevice -> StringState
    numberDeviceIsInState: NumberDevice -> Int  

    type lightDevice := {light_1, light_2, light_3} <: StringDevice
    type lightDeviceStates := {light_on, light_off} <: StringState  

    type dimmableLightDevice := {dimmable_light} <: NumberDevice
    type dimmableLightDeviceStates := {0..100} <: Int
}
\end{idplisting}

Having experimented with all three of the possibilities, we have decided to go with the third vocabulary with the split devices for number states and string states. It offers the user the flexibility they want, while keeping it as simple and convenient enough to model in a blocks based editor. The first vocabulary is a bit too simple and does not offer the user the flexibility they want in rule creation, though it is very easy to create blocks for it. The second vocabulary is complexer and offers a great flexibility in the rules that can be created. However, it is quite tedious to always specify the possible states for every device. While the third vocabulary is a bit more complex, we feel it is still easy to understand while making the device-creation easier.

\chapter{Implementation}
In this chapter we will discuss the blocks-based editor and the design-decisions we have made while creating it. We will also discuss how the application is structured and how it works.

\section{Blockly}

To create the blocks-based interface we used Blockly~\cite{Blockly}, a JavaScript-based framework for blocks-based editors. It is, at its core, a very flexible framework that allows you to create custom blocks that translate to code-snippets. We used it to create JSON-like structures that can be parsed into \fodot later on.

Blockly comes with basic programming blocks by default, but since those are not suitable for our \fodot descriptions, we created a custom set of blocks known as a toolbox. The toolbox defines how blocks are grouped and displayed in the editor. The actual appearance of each block is defined separately, and their behavior, how each block translates into a \fodot-compatible format, is handled by custom generator functions. Whenever the Blockly workspace updates, a main script ensures that the generated code stays in sync and that elements like dropdown menus reflect the latest state of the workspace.

When creating the custom blocks and deciding where to place them in the editor, we did a few things to make it as user friendly as possible. We made sure that the blocks that are related to each other, for example the blocks who define an area and the block that displays the relations between areas, are close and have the same tint of colour. This is an extra way of showing the user which blocks should be puzzled together. We also tried to make the blocks in a way that hides the underlying \fodot syntax as much as possible. We also dynamicially update the dropdown menus inside the blocks so the user can, for example, not select a devicetype when a state is needed. In Figure~\ref{fig:homy} all the custom blocks we used are shown. The blocks will be discussed in more detail in the following Section~\ref{custom_blocks}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/homy.png}
    \caption{All the custom blocks for the blocks-based editor}
    \label{fig:homy}
\end{figure}

\section{Custom blocks}
\label{custom_blocks}
In this section we will go over all the blocks we created, how they translate in \fodot, and how we imagine them being used. In addition to the blocks there are also buttons, e.g, to create a new devicetype or a new area. These will also be discussed here. The focus lies on the blocks and how they translate to \fodot, not on the complete \fodot description. Throughout this section we will use the example shown in Figure~\ref{fig:custom_blocks_example}. The rules that go with this example are:
\begin{itemize}
    \item If ``light\_switch\_1'' is in state ``light\_switch\_on'', ``light\_3'' should be in state ``light\_on''.
    \item If ``light\_switch\_1'' is in state ``light\_switch\_on'', ``light\_1'' and ``light\_2'' should be in state ``light\_off''.
    \item If ``light\_switch\_1'' is in state ``light\_switch\_off'', ``light\_1'' and ``light\_2'' should be in state ``light\_on''.
    \item If ``light\_switch\_1'' is in state ``light\_switch\_off'', ``light\_3'' should be in state ``light\_off''.
\end{itemize}
Its equivalent modeled in the editor is shown in Figure~\ref{fig:homy_example}. We will go over the blocks used in the example to explain how they work. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/custom_blocks_example.png}
    \caption{An example of a simple home}
    \label{fig:custom_blocks_example}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/homy_example.png}
    \caption{The example modeled in the blocks-based editor}
    \label{fig:homy_example}
\end{figure}

\subsection{States}
States are used to specify the possible states of a device. For instance, a light can be in the states ``light\_on'' and ``light\_off''. States are created using a button. When the button is clicked, the user gets a prompt asking for the name of the state. After they have entered a name, the state is added to the globally defined array that holds all the states. This is done so the blocks that require the states can only display the existing states, which makes it easier for the user to select the right state. This is how states are created for devices that require strings as state. However, some devices require a number as state, for example a thermostat. It should be able to represent a temperature range, e.g. 16-25. The difference between the ``number-device'' and ``string-device'' is further explained when discussing the devicetypes. There is no immediate translation to \fodot code when a state is created. All the blocks related to the states are shown in Figure~\ref{fig:homy_state_blocks}, and will be further explained in the context with other blocks, since any state-block should not be used on its own.

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{images/homy_state_blocks.png}
    \caption{The blocks related to the states}
    \label{fig:homy_state_blocks}
\end{figure}

\subsection{Areas}
An area is a physical location in the house, for example, a living room or a kitchen. Areas are created in the same way as states, using a button that writes new areas to a globally defined array. There is however an extra block that is used to define the relations between the areas. This is so the user can define relations between the areas, for example ``the living room is inside the home''. An example of this combination can be found in Figure~\ref{fig:homy_area_relation}.

The block has a direct \fodot translation in the structure as shown below. 
\begin{idplisting}
structure S:V {
    areaIsSubAreaOf := {(living_room, home), (kitchen, home)}.
}
\end{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{images/homy_area_relation.png}
    \caption{An example of defining the relation between two areas}
    \label{fig:homy_area_relation}
\end{figure}

\subsection{Devicetypes creation}
A deviceType is a group of devices who share the same states. For example, the deviceType ``light'' groups all the lights, who have the states ``light\_on'' and ``light\_off'', together. The devicetypes are created in the same way as areas and states. Since the devicetypes still require the user to specify the states of the devicetype, there is no explicit \fodot translation.

\subsection{Devicetypes definition}
The yellow block shown in Figure~\ref{fig:homy_device_type} is used to specify the states of a given devicetype. There are two different types of devicetypes, since there are two types of devices, however, this does not reflect in the deviceType block since this is already done in the states. Behind the scenes, the program looks whether or not the states that define the deviceType are convertable to numbers, after which it adds the new deviceType to the correct supertype. In the case of a light switch, the devicetype ``light\_switch'' has two states: ``light\_switch\_on'' and ``light\_switch\_off''. The block is used to define the states of a device, so the user can select the states of a device when creating it. The block has a direct \fodot translation, both in the vocabulary and theory as shown below. Note that the first line in the vocabulary does not yet specify specific devices that are of the type ``light\_switch'', as these will be added when the user creates a device of that type.
\begin{idplisting}
vocabulary V {
    type light_switchDevice := {} <: StringDevice
    type light_switchDeviceStates := {light_switch_on, light_switch_off} <: StringState
}
theory T:V {
    !dt in light_switchDevice: ?x in light_switchDeviceStates: stringDeviceIsInState(dt) = x.
}
\end{idplisting}

Note that we also introduce a formula in the theory to state that the device is in one of the states of the devicetype. This prevents, e.g, that a ``light\_switch'' can be set to ``light\_on''.

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{images/homy_device_type.png}
    \caption{An example of defining the states of a device}
    \label{fig:homy_device_type}
\end{figure}

\subsection{Devices}
A device is created using the red block shown in Figure~\ref{fig:homy_device}. The user needs to specify the name of the device, the devicetype and the area it is in. For example, a device called ``light\_switch\_1'' is of the type ``light\_switchDevice'' and is located in the l``iving\_room''. The block has a direct \fodot translation, shown below. However, this again depends on whether it is a number or string device. The line created by the devicetype-block is changed to include the newly defined device.

\begin{idplisting}
vocabulary V {
    type stringDevice := {light_switch_1} 
    type light_switchDevice := {light_switch_1} <: stringDevice
}
Structure S:V {
    stringDeviceIsInArea := {light_switch_1->living_room}.
}
\end{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/homy_device.png}
    \caption{An example of a new device}
    \label{fig:homy_device}
\end{figure}

\subsection{Specific rules}
The blocks shown in Figure~\ref{fig:homy_single_rule} are used to create a standalone rule. The user can create a pre- and postcondition as complex as needed. After which the user selects a device of which the state is changed when the first part of the rule is true. For example, if the ``light\_switch\_1'' is in the state ``light\_switch\_on'', ``light\_3'' should be in the state ``light\_on''. This corresponds to the following \fodot.

\begin{idplisting}
stringDeviceIsInState(light_switch_1) = light_switch_on =>
stringDeviceIsInState(light_3) = light_on.
\end{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/homy_single_rule.png}
    \caption{An example of a single rule}
    \label{fig:homy_single_rule}
\end{figure}

\subsection{Enumerating rules over devicetypes}
The blocks shown in Figure~\ref{fig:homy_enumerate_rule_devicetype} are used to create a rule that is true for all devices of a certain type. It only enumerates over one type at once, not multiple at the same time. This is done so there is no confusion in the blocks that need to specify the rule that applies for the devices. If multiple devicetypes were possible, each devicetype should have its own name in the scope of the block to be able to use it, which would make it confusing. The user selects a device which state dictates whether or not the rule is true. After which the user selects a state in which all the devices of that type should be in. For example, if the ``light\_switch\_1'' is in the state ``light\_switch\_off'', all the lights should be in the state ``light\_off''. The block has a direct \fodot translation, shown below.

\begin{idplisting}
!DT in LightDevice: stringDeviceIsInState(light_switch_1) = light_switch_off =>
stringDeviceIsInState(DT) = light_off.
\end{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/homy_enumerate_rule_devicetype.png}
    \caption{An example of the blockly block that creates an enumerating rule}
    \label{fig:homy_enumerate_rule_devicetype}
\end{figure}

\subsection{Quantifying rules over areas}
The blocks shown in Figure~\ref{fig:homy_enumerate_rule_area} are used to create a rule that is true for all devices in a certain area. The user selects an area who limits the selected devices to the devices in that area. The user can now input one of the previous rules to create a rule that applies only in a certain area. For example, if the ``light\_switch\_1'' is in the state ``light\_switch\_on'', all the lights in the kitchen should be in the state ``light\_on''. The block has a direct \fodot translation, shown below.

\begin{idplisting}
!DT in LightDevice: (stringDeviceIsInArea(DT) = kitchen) & (stringDeviceIsInState(light_switch_1) = light_switch_on) => stringDeviceIsInState(DT) = light_on.
\en{idplisting}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/homy_enumerate_rule_area.png}
    \caption{An example of the blockly block that creates a quantifying rule over areas}
    \label{fig:homy_enumerate_rule_area}
\end{figure}

\subsection{Save}
The save button is used to save the current workspace and translate it to \fodot. It takes all the blocks currently in the workspace and sends them to the back-end. After the blocks are parsed into \fodot code, another process is started where the Interactive Consultant of IDP-Z3 is started with the \fodot description is already loaded. It is important to note that the user does not get corrected on their mistakes in the blocks-based editor, since the IDP-Z3 engine provides a way to explain errors.

\section{\fodot parsing and IDP-Z3 integration}
For the generating of the \fodot code we used Python, done locally on the user's machine. When the user saves their constructed KB, the blocks translated each to a JSON-like structure, when they are all parsed, they are sent to the back-end which translates them into valid \fodot rules.
An example of how the JSON-like structure is parsed is shown below.
\begin{verbatim}
__NEW_DEVICE__{{
    "deviceName": "light_0", 
    "deviceType": "light", 
    "deviceArea": "home"
}}
\end{verbatim}
Every JSON-like structure has the same format having a function name, followed by a JSON with all the parameters in it.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/blockly_new_device.png}
    \caption{An example of a blockly block that creates a new device}
    \label{fig:blockly_new_device}
\end{figure}

In this case the block shown in Figure~\ref{fig:blockly_new_device} would, by the generator in blockly, be parsed into the above JSON-like structure. After which it is translated into the following \fodot code:

\begin{idplisting}
vocabulary V {
    type StringDevice := {light_0}
    type lightDevice := {light_0} <: Device
}
structure S:V {
    deviceIsInArea := {light_0 -> home}.
}
\end{idplisting}

After parsing every block to valid \fodot code, the code is written to a file, after which the Interactive Consultant of IDP-Z3 is started. This is done in a separate process keeping the blockly server running. This allows the user to correct semantic errors in their knowledge base without having to reset everything.

\section{Interactive Consultant}
The Interactive Consultant is used as a validation tool for the created KB. It helps the user understand their mistakes and correct them and gives the user a way to explore their KB and find any semantic errors. This is a crucial part of the application since, according to the study done by Sheik Murad Hassan Anik et. all~\cite{SOTA_AutomationConfigurationSmarthome}, error detection and correction is one of the hardest, but most important, parts of a home automation system.

\chapter{User study}
To test whether or not our created application is in fact user-friendly and is able to achieve the flexibility we wanted, we performed a user study. In this chapter we will elaborate on our approach and discuss results of this study.

\section{Methodology}
We searched for participants who had no, or little, prior knowledge of home automation, programming or \fodot, to mitigate bias. Our testing group consisted of 14 participants. Before going to the actual testing, we asked an external tester to already try the application and give us feedback. This was done so we could change things that were intuitive for us as creators, but unintuitive for them. Based on this feedback, we changed the application a bit and adjusted the created manual.

To guide the experiment, we created a manual (Appendix~\ref{appendix:manual}). This explained what home automation is, what the intend is of automating your home. It mentions concepts like areas, devices, devicetypes and rules who are all nesessary to understand the application. The manual also gives some example of how to create these concepts using the editor, however these examples do not cover every single block, this way the user can still explore the options available in the editor. It also features a fully premade simple example of a light that is controlled by a lightswitch. In this way, the user has a rough idea of how a home should be modeled in the editor. We send the testers the manual some time before the tests, so they can read it on their own pace and get familiar with the concepts and the structure of the application.

After they have read the manual, we asked the testers to model some simple homes in the form of cases. These are small examples of homes that are easy to understand and do not require a lot of knowledge about home automation. Each case is further described in Section~\ref{cases}. Similar to the test methodology of SmartBlock~\cite{SOTA_SmartBlock}, the cases ramp up in difficulty the further the tester goes. Once the tester has effectively modeled a case, they were asked to check their created KB in the Interactive Consultant of IDP-Z3. This way they could see if their model was correct and if it was not, they could fix it in the blocks-based editor.

Finally, we asked the participants to fill in a questionnaire. It had some questions about the blockly-part of the application, the IC-part, whether or not it was easy to use and whether or not they felt confident in their ability to create a home automation system with this editor and their aquired knowledge. This will be further explained in Section~\ref{results}.

\section{Cases}
\label{cases}
In this section we will discuss the cases we used in our study.
\subsection{Case 1}
Case 1 is the simplest case, with no real extra complexity from the example given in the manual. It is to let the user use the blocks and workflow for the first time. This was also done in the SmartBlock~\cite{SOTA_SmartBlock} application. The case consists of 3 lights and a lightswitch in a living room and a kitchen, as shown in Figure~\ref{fig:case_1}. The rules that go with this case are:
\begin{itemize}
    \item ``light\_3'' should turn on if ``light\_switch\_1'' is on.
    \item ``light\_1'' and ``light\_2'' should turn off if ``light\_switch\_1'' is turned on.
    \item ``light\_1'' and ``light\_2'' should turn on if ``light\_switch\_1'' is turned off.
    \item ``light\_3'' should turn off if ``light\_switch\_1'' is off.
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/case_1.png}
    \caption{Case 1}
    \label{fig:case_1}
\end{figure}
A possible solution for this case in our editor is shown in Figure~\ref{fig:case_1_solution}. It is important to point out that this solution is not the only one possible. Most of the users used the ``and'' block to control the lights in the kitchen.
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/case_1_homy.png}
    \caption{A possible solution for case 1}
    \label{fig:case_1_solution} 
\end{figure}

\subsection{Case 2}
The second case is a bit more complex compared to the first case. It features ``stringDevices'' as well as ``numberDevices''. This makes the user experiment with this new type of device and how to model it in out system. The rules are still relatively simple, in the sense that they still only require a simple ``if-then''. However, they require the user use rule-blocks that go beyond the blocks used in the guide, the introduction of time is an example of a new block they now need. The case consists of 3 lights, 2 motion sensors, 1 temperature sensor and a fan, these last 2 types are ``numberDevices''. The case is shown in Figure~\ref{fig:case_2}. The rules that go with this case are:
\begin{itemize}
    \item ``light\_3'' should turn on if ``motion\_sensor\_1'' or ``motion\_sensor\_2'' is active.
    \item ``fan\_1'' should turn on to 80 if ``temperature\_sensor'' is 30.
    \item ``light\_1'' and ``light\_2'' should turn off if the time is 8.
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/case_2.png}
    \caption{Case 2}
    \label{fig:case_2}
\end{figure}
A possible solution for this case in our editor is shown in Figure~\ref{fig:case_2_solution}. Just as in case 1, this is not the only solution.
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/case_2_homy.png}
    \caption{A possible solution for case 2}
    \label{fig:case_2_solution}
\end{figure}

\subsection{Case 3}
In the last case, the user was asked to model the most complex home of the three cases. It requires more difficult rules, making use of everything the user has learned so far. The case consists of 3 lights, 2 lightswitches, 1 alarm, 1 blind, 1 motion sensor, 1 variable light and a variable light switch. The case is shown in Figure~\ref{fig:case_3}, as is a possible solution in Figure~\ref{fig:case_3_solution}. The rules that go with this case are:
\begin{itemize}
    \item ``light\_1''  and ``light\_2'' should turn on if either ``light\_switch\_1'' or ``light\_switch\_2'' is on, but not both. Think of it as lightswitches on different floors that control 1 light.
    \item all the lights of type ``light'' should turn on and the alarm should turn on, if the time is 2 and ``motion\_sensor\_1'' is in the state ``motion\_sensor\_on''.
    \item ``variable\_light\_switch\_1'' controls the state of ``variable\_light\_1''.
    \item ``variable\_light\_1'' should turn off (value = 0) and ``light\_3'' should turn on if it the time is 4.
    \item ``variable\_light\_1'' should have a value of 40 and ``blind\_1'' should be half\_opened, if the time is 6.
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/case_3.png}
    \caption{Case 3}
    \label{fig:case_3}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/case_3_homy.png}
    \caption{A possible solution for case 3}
    \label{fig:case_3_solution}
\end{figure}

\section{Results}
\label{results}
In this section, we will discuss the results of the user study. First, we will present our findings during the modeling of the cases. After that, we will go over the results of the questionnaire and discuss what these results mean for our application.

\subsection{Modeling the cases}
All participants completed the cases while someone who created the application was present with them. They did not assist the participants with the editor or IC in any way but were available to answer questions if there were any about the cases. The presence of someone also provided us with useful information about the difficulties the participants encountered with the application. One such difficulty was the distinction between deviceTypes and the devices themselves. This could be observed when users inputted device names into the deviceType button. However, this mostly occurred in case 1 and became less of an issue afterwards. Some participants did not struggle with this at all.

Another observation was the speed at which participants modeled the cases. They spent approximately the same amount of time on each case, around 20 minutes. Since the cases increased in complexity, this indicates that participants improved over time. None of the participants seemed to struggle with the Blockly~\cite{Blockly} interface. There were no issues with connecting blocks, deleting blocks, duplicating blocks, navigating the menus and workspace, etc.


\subsection{Questionnaire}
The questionnaire was sent to the participants after they had modeled all the cases. It consisted of 14 questions about their IT knowledge, their previous experiences with blocks-based editors, the blocks, and the IC.

We had a fairly wide range of participants regarding their level of IT knowledge. The scores they gave themselves ranged from 3/10 to 9/10, with most of them around a 7 or 8 out of 10. It is worth noting that all the participants have their own idea of an IT-er. For some this is being able to work fluently with excel, others think it is being able to program. Only 21.4\% of the participants had no experience with any blocks-based editor. This is probably due to the fact that blocks-based editors are commonly used in schools to introduce young people to programming. The ages of our testers ranged from 14 to 52 years old.

The participants were asked to rate the complexity of the functionality of the blocks on a scale from 1 to 10. This was done to determine whether the testers found the functionality of each block easy to understand and use correctly. The average score was 8.5 out of 10, which shows that the testers found the blocks' functionality easy to understand and had no issues identifying which block should be used for what. The grouping of the blocks in the menus was rated 9.14 out of 10, indicating that the organization of the blocks in the different menus was easy to follow and made sense.

They were also asked about the complexity of the blocks, in other words, whether the blocks contained too much functionality, making them confusing for users. The average score for that question was 8.43 out of 10, suggesting the blocks were not too complex. We also coloured the blocks in a way that made it easier to see which blocks should be used together. The testers were asked about this, and their answers were divided. Some of them did not notice that the colours had meaning, while others thought it was helpful. There were also participants who noticed it but did not find it helpful. The average score—though due to the wide range of opinions, it should be taken with a grain of salt—was 6.36 out of 10.

The participants were also asked about the IC and how useful it is during the modeling of the cases. They gave it a 9.36 out of 10, which further demonstrates the usefulness of the IC. They found it very helpful to see whether their model behaved as expected and to change blocks if there were any mistakes. Not all participants made a mistake in their model (5 out of the 14 did not), but those who did found the IC to be a very helpful verification tool. They gave it a score of 7.67 out of 10 for its usefulness in that regard.

The testers were asked to rate the overall user-friendliness of the blocks and the IC. The average scores were 8.71 out of 10 for both categories, showing that the testers found the application easy to use overall. As a final question, they were asked whether they felt confident in their ability to create a home automation system using this application after the small introduction through the cases. Their confidence was rated at an average of 8.42 out of 10.

\begin{table}
    \centering
    \begin{tabular}{|l|l|}
        \hline
        Question & Average score (out of 10)\\
        \hline
        Easy functionality of the blocks & 8.5 \\
        Grouping of the blocks in the menus & 9.14 \\
        Functionality of the blocks was not too much & 8.43 \\
        Usefulness of the colours & 6.36 \\
        Usefulness of the IC & 9.36 \\
        User-friendliness of the blocks & 8.71 \\
        User-friendliness of the IC & 8.71 \\
        Confidence in creating a home automation system & 8.42 \\
        \hline
    \end{tabular}
    \caption{Results of the questionnaire}
    \label{tab:questionnaire_results}
\end{table}

\subsection{Discussion}
The results of the user study show that our application is quite user-friendly. The participants did not have much trouble using the application and modeling the cases. The colours of the blocks were not as helpful as we had hoped, but they did assist some users. The IC was rated very highly in terms of usefulness, which aligns with the findings on rule validation from the SmartBlock~\cite{SOTA_SmartBlock} paper. The fact that five users did not make any mistakes during the modeling—despite having no prior knowledge of home automation—is another sign that the application is user-friendly. Those who did make mistakes were able to find them with the help of the IC.

All these results need to be taken with a grain of salt, as the number of testers was not large enough to draw definitive conclusions. However, it is a good indication of how the application is perceived by users.

\paragraph{Limitations of the application}
A limitation of our small case size is that the application was not tested on larger homes. Therefore, we cannot make any claims about the scalability of the application. One issue we did encounter is that, since the deviceTypes, areas, and states are created using a button, the user cannot access or edit them afterwards. This was not a major issue because the cases were small, but if the application were to be used for full homes, this could become problematic.

At the moment, the application can only be used to create a home automation system. The application is only a modeling tool; it does not offer any means to control devices or areas outside of the IC. If this were to become a real application, IDP-Z3 would need to run regularly to detect changes in the home, so that the structure part of the \fodot description can be updated to reflect the new home situation.

Currently, it is not possible to create every complex rule. However, this is more a limitation of the available blocks than of the expressiveness of the \fodot language. For example, blocks like "greater than" are not yet available but are not difficult to add to the application. The definition of time is also not ideal, as it is currently just a number. This could be improved by adding a few blocks for repeated events, such as “every Friday at 8 a.m.” This would enable users to create rules that would definitely be useful when modeling an actual home.

There is also no way to create a device that has both numbers and strings as states, due to the vocabulary we chose in Section~\ref{fodot_knowledge_base}. It is possible that other vocabularies would allow for this added expressiveness, but we did not find any that support this while keeping the system simple enough to be modeled in a blocks-based editor.


\chapter{Conclusion}
In this thesis we created an application for home automation using a first order logic language in combination with a reasoning engine. We identified previous issues with home automation modeling and tried to adress them using the formal language \fodot and the IDP-Z3 system. Given that this language is not easy to learn and understand, we explored alternative options for user interaction. We landed on a blocks-based editor as the most effective for this cause. Following this we tought about the way the \fodot code should be structured and created a blocks-based editor that allows the user to model their own knowledge bases / home automation systems. After the creation of the knowledge base, the user could check whether or not their constructed KB was correct using the Iteractive Consultant of IDP-Z3. During the creation of this editor we kept a close eye on the user-friendliness and the different rules a user would want to be able to model. After the creation of the application, we did a user study to test whether or not we succeeded in our goal of creating a user-friendly application while keeping the expressiveness of the \fodot language and the advantages of the IDP-Z3 system. These tests showed that our application is indeed considered fairly user-friendly. The testers had a great feeling for the functionality and structure of the application while getting better and better throughout the presented cases. The validation tool, aka the Interactive Consultant, helped the users test their KB and correct any mistakes they made. The confidence of our test group in their ability to create a home automation system using our application was high, even though they had no prior knowledge of home automation. While our group was small, it is a good indication of the user-friendliness of our application.

\section{Future work}
This work is sertainly not finished, there is still lots of work to be done. The application can not stand on its own, in the sence that it does not allow to connect with actual physical devices. However, this is crutial if it were to be used in a real home automation setting. The communication with the hardware in a home is however already done well in Home Assistant~\cite{HA}, it would be great if this application could be something that is integrated into the HA system. The problems the testers had with the difference between deviceTypes and devices would automaticially be solved by this, since HA can already figure out the states of many physical devices.

The blocks-based editor could also be improved by adding more blocks, such as the "greater than" block, which would allow for more complex rules to be created. The definition of time could also be improved by adding blocks for repeated events, such as "every Friday at 8 a.m." This would enable users to create rules that would now be tedious or even impossible to create.

Regarding the \fodot backbone, it would be great if more vocabularies would be explored. The current vocabulary works well, but is definitely not the only one or the best one. It would be interesting to see if other vocabularies would allow for more expressiveness, such as the ability to create devices that have both numbers and strings as states, while keeping the system simple enough to be modeled in a blocks-based editor. Even the possibility of other languages could be explored, such as SWRL as done in~\cite{SOTA_OntologyBased}.

The user study also needs to be expanded. While the current study shows that the application is user-friendly, it was done with a small group of testers. A larger group would provide more reliable results and would probably reveal additional insights into the user experience.

\printbibliography

\appendix
\chapter{Appendix}
\section{The application}
\label{appendix:application}
All the code for the application can be found on our GitHub page: \url{https://github.com/MAAK_ER_NOG_EEN_MET_ENKEL_DE_CODE_OP}

\section{Hoe noem ik dit best?}
\label{appendix:waaaaaaaaaaaaaaaat}
The rules discribed in Section~\ref{Behaviour} actually created in the application.
Die figuren komen na de handleiding for some reason. Kan ik ze hier forceren?
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R1.png}
    \caption{Rule 1}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R2.png}
    \caption{Rule 2}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R3.png}
    \caption{Rule 3}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R4.png}
    \caption{Rule 4}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R5.png}
    \caption{Rule 5}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R6.png}
    \caption{Rule 6}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{images/R7.png}
    \caption{Rule 7}
\end{figure}
\section{The manual}
\label{appendix:manual}
\includepdf[pages=-]{appendix/manual.pdf}

\end{document}