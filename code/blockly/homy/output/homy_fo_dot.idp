vocabulary V {
	// DEFAULT NEEDED TYPES AND FUNCTIONS
	type Device := {light0, lightswitch, light1, radiator, rgb_light}
	type State := {on, off}
	type Area := {home}


	deviceIsInArea: Device -> Area
	// subArea * superArea -> Bool
	areaIsSubAreaOf: Area * Area -> Bool


	// GENERATED VOCABULARY
	type on_off_deviceDevice := {} <: Device
	type on_off_deviceDeviceStates := {on, on, on}
}
theory T : V {
	// DEFAULT NEEDED RULES
	!dt in on_off_deviceDevice: ?x in on_off_deviceDeviceStates: deviceIsInState(dt) = x.
	// NOG EEN MANIER VINDEN OM INT DEVICES TOE TE LATEN...
	!dt in on_off_deviceDevice: ?x in on_off_deviceDeviceStates: deviceIsInState(dt) = x.
	!DT in on_off_device: deviceIsInState(null) = off <=> deviceIsInState(DT) = off.
	!d in Device: deviceIsInArea(d) = home & !DT in on_off_device: deviceIsInState(null) = on <=> deviceIsInState(DT) = on.
	!d in Device: deviceIsInArea(d) = home & !DT in integer_device: deviceIsInState(null) = on <=> deviceIsInState(DT) = 50.
}
structure S : V {
	deviceIsInArea := {(light0 -> home), (lightswitch -> home), (light1 -> home), (radiator -> home), (rgb_light -> home)} .
	areaIsSubAreaOf := {(home, home), (home, home)} .
}