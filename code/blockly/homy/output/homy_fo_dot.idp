vocabulary V {
	// DEFAULT NEEDED TYPES AND FUNCTIONS
	type StringDevice := {blindieee, blindieee2}
	type NumberDevice := {dimmie, dimmie2}
	type StringState := {on, off, opened, closed}
	type Area := {home, floor1, floor2}
	time: () -> Int


	stringDeviceIsInArea: StringDevice -> Area
	numberDeviceIsInArea: NumberDevice -> Area
	// subArea * superArea -> Bool
	areaIsSubAreaOf: Area * Area -> Bool


	stringDeviceIsInState: StringDevice -> StringState
	numberDeviceIsInState: NumberDevice -> Int
	// GENERATED VOCABULARY
	type blindDevice := {blindieee, blindieee2} <: StringDevice
	type blindDeviceStates := {opened, closed} <: StringState
	type dimmerDevice := {dimmie, dimmie2} <: NumberDevice
	type dimmerDeviceStates := {0..100} <: Int
}
theory T : V {
	// DEFAULT NEEDED RULES
	!dt in on_off_deviceDevice: ?x in on_off_deviceDeviceStates: deviceIsInState(dt) = x.
	// NOG EEN MANIER VINDEN OM INT DEVICES TOE TE LATEN...
}
structure S : V {
\stringDeviceIsInArea := {blindieee -> floor1, blindieee2 -> floor2} .
	numberDeviceIsInArea := {dimmie -> floor1, dimmie2 -> floor2} .
	areaIsSubAreaOf := {(floor1, home), (floor2, home)} .
}