vocabulary V {
	// DEFAULT NEEDED TYPES AND FUNCTIONS
	type StringDevice := {light_1, light_2, light_3, light_switch_1}
	type NumberDevice := {}
	type StringState := {light_on, light_off, light_switch_on, light_switch_off}
	type Area := {home}
	time: () -> Int


	stringDeviceIsInArea: StringDevice -> Area
	numberDeviceIsInArea: NumberDevice -> Area
	// subArea * superArea -> Bool
	areaIsSubAreaOf: Area * Area -> Bool


	stringDeviceIsInState: StringDevice -> StringState
	numberDeviceIsInState: NumberDevice -> Int
	// GENERATED VOCABULARY


	type lightDevice := {light_1, light_2, light_3} <: StringDevice
	type lightDeviceStates := {light_on, light_off} <: StringState
	type light_switchDevice := {light_switch_1} <: StringDevice
	type light_switchDeviceStates := {light_switch_on, light_switch_off} <: StringState
}
theory T : V {
	!dt in lightDevice: ?x in lightDeviceStates: stringDeviceIsInState(dt) = x.
	!dt in light_switchDevice: ?x in light_switchDeviceStates: stringDeviceIsInState(dt) = x.
	(  (stringDeviceIsInState(  light_switch_1) =   light_switch_on)) => (  (stringDeviceIsInState(  light_3) =   light_on)).
	(  (stringDeviceIsInState(  light_switch_1) =   light_on)) => (    (stringDeviceIsInState(  light_1) =   light_off) &   (stringDeviceIsInState(  light_2) =   light_off) ).
	(  (stringDeviceIsInState(  light_switch_1) =   light_switch_off)) => (    (stringDeviceIsInState(  light_1) =   light_on) &   (stringDeviceIsInState(  light_2) =   light_on) ).
	(  (stringDeviceIsInState(  light_switch_1) =   light_switch_off)) => (  (stringDeviceIsInState(  light_3) =   light_off)).
}
structure S : V {
	stringDeviceIsInArea := {light_1 -> home, light_2 -> home, light_3 -> home, light_switch_1 -> home} .
	numberDeviceIsInArea := {} .
	areaIsSubAreaOf := {} .
}